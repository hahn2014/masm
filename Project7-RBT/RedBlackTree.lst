Microsoft (R) Macro Assembler Version 14.16.27027.1	    03/14/19 14:47:20
,Project 7 - RedBlackTree		(RedBlackTree.asm    Page 1 - 1


				TITLE Project 7 - RedBlackTree		(RedBlackTree.asm)

				; Author: Bryce Hahn
				; Project ID: Project 7
				; Date: 3/13/2019
				; Description:
				;	Red Black Tree, options to read in values from
				;	a given file, auto generated within a given
				;	number of values, or through user input. Prints
				;	sorted tree to the console.

				INCLUDE Irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 

 00000000			.data
 = 00000001			MINIMUM			=		1																					; The min number of nodes that can be written
 = 000001F4			MAXIMUM			=		500																					; The max number of nodes that can be written
 = 000003E8			MAXIMUMVAL		=		1000																				; highest value enterable into the array
 00000000  000001F4 [		unsorted_list	DWORD	MAXIMUM DUP(?)																		; The list that unsorted values will be placed in with a max array size of 500
	    00000000
	   ]
 = 00001388			BUFFER_SIZE		=       5000																				; Max size for a file buffer
 000007D0  00001388 [		buffer			DWORD   BUFFER_SIZE dup (?)																	; file buffer
	    00000000
	   ]
 000055F0 00000000		bytesRead		DWORD	0																					; temp to keep track of bytes
 000055F4 00000000		infileH			DWORD   0
 000055F8 69 6E 70 75 74	inFilename		BYTE    "input.txt", 0																		; file name
	   2E 74 78 74 00


				;#region Macro Setup

				;---------------------------------------------------------------;
				;	Macro mPrintString replaces having to move a byte to edx	;
				;	and call writeString with only one line. also allows for	;
				;	pretty lazy debuging which is a plus.						;
				;	THIS METHOD ONLY WORKS WITH VARAIBLES						;
				;---------------------------------------------------------------;
				mWriteString	MACRO	buffer:REQ
					push	edx
					mov		edx, OFFSET buffer
					call	WriteString
					pop		edx
				ENDM
				;---------------------------------------------------------------;
				;	Macro mWriteStringLn is the same as mWriteString but adds	;
				;	a new line after the printed text so you don't have to write;
				;	a new line call in the main functions.						;
				;---------------------------------------------------------------;
				mWriteStringLn	MACRO	buffer:REQ
					mWriteString	buffer
					call	CrLf
				ENDM
				;---------------------------------------------------------------;
				;	Macro mWriteDec prints out an Integer to the screen, this	;
				;	can be either a whole integer or a decimal					;
				;---------------------------------------------------------------;
				mWriteDec		MACRO	decimal
					push	eax
					mov		eax, decimal
					call	WriteDec
					pop		eax
				ENDM
				;---------------------------------------------------------------;
				;	Macro mWrite lets you write a string to the output without	;
				;	pre-emptively defining it, I.E in quotes you can write		;
				;	anything to the output.										;
				;---------------------------------------------------------------;
				mWrite			MACRO	text
					LOCAL	string
					.data
					string	BYTE	text, 0
					.code
					push	edx
					mov		edx, OFFSET string
					call	WriteString
					pop		edx
				ENDM
				;---------------------------------------------------------------;
				;	Macro mWriteLn is the same as mWrite but adds a new line	;
				;	call at the end so you don't have to write on in the code	;
				;	section of the functions.									;
				;---------------------------------------------------------------;
				mWriteLn		MACRO	text
					mWrite	text
					call	CrLf
				ENDM
				;#endregion

 00000000			.code
				;---------------------------------------------------------------;
				;	main PROC will be called once the program is run, this		;
				;	is where we can call other processes so that we aren't		;
				;	crowded into the main function like this (GROSS), so we		;
				;	will implement this into further projects.					;
				;---------------------------------------------------------------;
 00000000			main	PROC
 00000000  E8 00000011				call		Intro																					; Introduce the user to the program
 00000005  E8 00000060				call		GetUserRunOption																		; Get the user desired run option
 0000000A  E8 0000008C				call		ExecuteRunOption																		; Start the tree construction based on user option
						
					exit																									; close program, return to OS
 0000000F  6A 00	   *	    push   +000000000h
 00000011  E8 00000000 E   *	    call   ExitProcess
 00000016			main	ENDP																								; the main PROC is finished, this symbolyses that we are done with the proc

				;---------------------------------------------------------------;
				;	The intro procedure will be called right off the bat, sort	;
				;	of like before using procedures. This will allow to keep	;
				;	the main function clean and organized, making debugging		;
				;	easier! This function litterally just calls all intro		;
				;	scripts.													;
				;																;
				;	Parameters:		n/a											;
				;	Returns:		n/a											;
				;	Pre-Conditions:	called varaibles must be real strings		;
				;	Changed Regs:	eax, edx									;
				;---------------------------------------------------------------;
 00000016			Intro	PROC
 00000016  B8 00000003			mov				eax, cyan + (black * 16)																; color varaibles consist of: black, white, brown, yellow, blue, green, cyan, red, magenta, gray, 
 0000001B  E8 00000000 E		call			setTextColor																			;							  lightBlue, lightGreen, lightCyan, lightRed, lightMagenta, and lightGray.

					mWriteLn		"Welcome to Red-Black Tree Sorting! Please select one of the following:"
 00005602		     2		.data
 00005602 57 65 6C 63 6F     2		??0000	BYTE	"Welcome to Red-Black Tree Sorting! Please select one of the following:", 0
	   6D 65 20 74 6F
	   20 52 65 64 2D
	   42 6C 61 63 6B
	   20 54 72 65 65
	   20 53 6F 72 74
	   69 6E 67 21 20
	   50 6C 65 61 73
	   65 20 73 65 6C
	   65 63 74 20 6F
	   6E 65 20 6F 66
	   20 74 68 65 20
	   66 6F 6C 6C 6F
	   77 69 6E 67 3A
	   00
 00000020		     2		.code
 00000020  52		     2		push	edx
 00000021  BA 00005602 R     2		mov		edx, OFFSET ??0000
 00000026  E8 00000000 E     2		call	WriteString
 0000002B  5A		     2		pop		edx
 0000002C  E8 00000000 E     1		call	CrLf
					mWriteLn		"[1] Read values from input.txt"
 00005649		     2		.data
 00005649 5B 31 5D 20 52     2		??0001	BYTE	"[1] Read values from input.txt", 0
	   65 61 64 20 76
	   61 6C 75 65 73
	   20 66 72 6F 6D
	   20 69 6E 70 75
	   74 2E 74 78 74
	   00
 00000031		     2		.code
 00000031  52		     2		push	edx
 00000032  BA 00005649 R     2		mov		edx, OFFSET ??0001
 00000037  E8 00000000 E     2		call	WriteString
 0000003C  5A		     2		pop		edx
 0000003D  E8 00000000 E     1		call	CrLf
					mWriteLn		"[2] Auto-Generate a given number of values"
 00005668		     2		.data
 00005668 5B 32 5D 20 41     2		??0002	BYTE	"[2] Auto-Generate a given number of values", 0
	   75 74 6F 2D 47
	   65 6E 65 72 61
	   74 65 20 61 20
	   67 69 76 65 6E
	   20 6E 75 6D 62
	   65 72 20 6F 66
	   20 76 61 6C 75
	   65 73 00
 00000042		     2		.code
 00000042  52		     2		push	edx
 00000043  BA 00005668 R     2		mov		edx, OFFSET ??0002
 00000048  E8 00000000 E     2		call	WriteString
 0000004D  5A		     2		pop		edx
 0000004E  E8 00000000 E     1		call	CrLf
					mWriteLn		"[3] Input each individual values"
 00005693		     2		.data
 00005693 5B 33 5D 20 49     2		??0003	BYTE	"[3] Input each individual values", 0
	   6E 70 75 74 20
	   65 61 63 68 20
	   69 6E 64 69 76
	   69 64 75 61 6C
	   20 76 61 6C 75
	   65 73 00
 00000053		     2		.code
 00000053  52		     2		push	edx
 00000054  BA 00005693 R     2		mov		edx, OFFSET ??0003
 00000059  E8 00000000 E     2		call	WriteString
 0000005E  5A		     2		pop		edx
 0000005F  E8 00000000 E     1		call	CrLf
 00000064  E8 00000000 E		call			CrLf
 00000069  C3				ret
 0000006A			intro	ENDP

				;---------------------------------------------------------------;
				;	The GetUserRunOption procedure takes in the user input to	;
				;	decide which option the program will go with. The procedure	;
				;	actively validates inputs to ensure proper options.			;
				;																;
				;	Parameters:		n/a											;
				;	Returns:		n/a											;
				;	Pre-Conditions:	n/a											;
				;	Changed Regs:	eax, edx									;
				;---------------------------------------------------------------;
 0000006A			GetUserRunOption PROC
 0000006A				startUserInput:
						mWrite		"Please choose and option [1-3]: "
 000056B4		     1		.data
 000056B4 50 6C 65 61 73     1		??0004	BYTE	"Please choose and option [1-3]: ", 0
	   65 20 63 68 6F
	   6F 73 65 20 61
	   6E 64 20 6F 70
	   74 69 6F 6E 20
	   5B 31 2D 33 5D
	   3A 20 00
 0000006A		     1		.code
 0000006A  52		     1		push	edx
 0000006B  BA 000056B4 R     1		mov		edx, OFFSET ??0004
 00000070  E8 00000000 E     1		call	WriteString
 00000075  5A		     1		pop		edx
 00000076  33 C0				xor			eax, eax																				; Completly clear eax register
 00000078  E8 00000000 E			call		ReadDec																					; get user input

 0000007D				verifyUserInput:
 0000007D  83 F8 01				cmp			eax, 1																					; make sure the user inputed something within 1-3 range
 00000080  7C 06				jl			invalidInput																			; too low of an input value
 00000082  83 F8 03				cmp			eax, 3
 00000085  7F 01				jg			invalidInput																			; too high of an input value
 00000087  C3					ret

 00000088				invalidInput:
						mWriteLn	"The entered value was not within the given option range."
 000056D5		     2		.data
 000056D5 54 68 65 20 65     2		??0005	BYTE	"The entered value was not within the given option range.", 0
	   6E 74 65 72 65
	   64 20 76 61 6C
	   75 65 20 77 61
	   73 20 6E 6F 74
	   20 77 69 74 68
	   69 6E 20 74 68
	   65 20 67 69 76
	   65 6E 20 6F 70
	   74 69 6F 6E 20
	   72 61 6E 67 65
	   2E 00
 00000088		     2		.code
 00000088  52		     2		push	edx
 00000089  BA 000056D5 R     2		mov		edx, OFFSET ??0005
 0000008E  E8 00000000 E     2		call	WriteString
 00000093  5A		     2		pop		edx
 00000094  E8 00000000 E     1		call	CrLf
 00000099  EB CF				jmp			startUserInput

 0000009B			GetUserRunOption ENDP

				;---------------------------------------------------------------;
				;	The ExecuteRunOption process calls the given user inputted	;
				;	option for the program to continue.							;
				;																;
				;	Parameters:		option in eax								;
				;	Returns:		n/a											;
				;	Pre-Conditions:	eax contains 1-3 range options				;
				;	Changed Regs:	eax, edx									;
				;---------------------------------------------------------------;
 0000009B			ExecuteRunOption PROC
 0000009B  83 F8 01			cmp				eax, 1
 0000009E  74 0C			je				fileOption																				; User will run file load tree builder
 000000A0  83 F8 02			cmp				eax, 2
 000000A3  74 0D			je				generateOption																			; User will run auto-generated tree builder
 000000A5  83 F8 03			cmp				eax, 3
 000000A8  74 0E			je				inputOption																				; User will run self-inputed tree builder
 000000AA  EB 12			jmp				invalidOption																			; User somehow got past the int validater, end

 000000AC				fileOption:
 000000AC  E8 000000F2				call		LoadFileOption
 000000B1  C3					ret

 000000B2				generateOption:
 000000B2  E8 000001AB				call		GenerateValuesOption
 000000B7  C3					ret

 000000B8				inputOption:
 000000B8  E8 0000025B				call		InputValuesOption
 000000BD  C3					ret

 000000BE				invalidOption:
						mWriteLn	"Invalid Input! This error is a rare case where the invalid user input passed input checks..."
 0000570E		     2		.data
 0000570E 49 6E 76 61 6C     2		??0006	BYTE	"Invalid Input! This error is a rare case where the invalid user input passed input checks...", 0
	   69 64 20 49 6E
	   70 75 74 21 20
	   54 68 69 73 20
	   65 72 72 6F 72
	   20 69 73 20 61
	   20 72 61 72 65
	   20 63 61 73 65
	   20 77 68 65 72
	   65 20 74 68 65
	   20 69 6E 76 61
	   6C 69 64 20 75
	   73 65 72 20 69
	   6E 70 75 74 20
	   70 61 73 73 65
	   64 20 69 6E 70
	   75 74 20 63 68
	   65 63 6B 73 2E
	   2E 2E 00
 000000BE		     2		.code
 000000BE  52		     2		push	edx
 000000BF  BA 0000570E R     2		mov		edx, OFFSET ??0006
 000000C4  E8 00000000 E     2		call	WriteString
 000000C9  5A		     2		pop		edx
 000000CA  E8 00000000 E     1		call	CrLf
 000000CF  C3					ret

 000000D0			ExecuteRunOption ENDP

				;---------------------------------------------------------------;
				;	The PrintUnsortedList process is called once all the data	;
				;	has been stored into the unsorted array, and will then be	;
				;	printed to the screen to give the user a heads up on the	;
				;	data going into the tree.									;
				;																;
				;	Parameters:		unsorted_list								;
				;	Returns:		n/a											;
				;	Pre-Conditions:	unsorted_list contains at least 1 value		;
				;	Changed Regs:	eax, ebx, ecx, edx, esi						;
				;---------------------------------------------------------------;
 000000D0			PrintUnsortedList PROC
 000000D0  55				push			ebp
 000000D1  8B EC			mov				ebp, esp

 000000D3  BB 00000000			mov				ebx, 0
 000000D8  B9 00000000			mov				ecx, 0
 000000DD  BE 00000000 R		mov				esi, OFFSET unsorted_list

 000000E2				PrintLoop:
 000000E2  8B 04 9E				mov			eax, [esi + ebx * 4]																	; move current index value to eax
 000000E5  83 F8 00				cmp			eax, 0																					; first 0 we encounter is the end of the list
 000000E8  74 3B				je			EndPrint
						mWriteDec	eax
 000000EA  50		     1		push	eax
 000000EB  8B C0	     1		mov		eax, eax
 000000ED  E8 00000000 E     1		call	WriteDec
 000000F2  58		     1		pop		eax
 000000F3  41					inc			ecx																						; increase line print count
 000000F4  83 F9 0A				cmp			ecx, 10																					; see if we've printed 10 values on a line
 000000F7  74 02				je			NewLine
 000000F9  75 0C				jne			OldLine

 000000FB					NewLine:
 000000FB  E8 00000000 E				call	CrLf
 00000100  B9 00000000					mov		ecx, 0																					; start line count again
 00000105  EB 13					jmp		NextCall
 00000107					OldLine:
							mWrite	","
 0000576B		     1		.data
 0000576B 2C 00		     1		??0007	BYTE	",", 0
 00000107		     1		.code
 00000107  52		     1		push	edx
 00000108  BA 0000576B R     1		mov		edx, OFFSET ??0007
 0000010D  E8 00000000 E     1		call	WriteString
 00000112  5A		     1		pop		edx
 00000113  E8 00000014					call	PropSpacing
 00000118  EB 00					jmp		NextCall
 0000011A					NextCall:
 0000011A  43						inc		ebx
 0000011B  81 FB 000001F4				cmp		ebx, LENGTHOF unsorted_list
 00000121  74 02					je		EndPrint
 00000123  75 BD					jne		PrintLoop
 00000125				EndPrint:
 00000125  E8 00000000 E			call		CrLf
 0000012A  5D					pop			ebp
 0000012B  C3					ret
 0000012C			PrintUnsortedList ENDP

				;---------------------------------------------------------------;
				;	The PropSpacing procedure will be called when spacing out	;
				;	the unsorted values to align them properly.					;
				;																;
				;	Parameters:		current value [ebp - 8]						;
				;	Returns:		n/a											;
				;	Pre-Conditions:	unsorted_list contains at least 1 value		;
				;	Changed Regs:	eax, edx, edi								;
				;---------------------------------------------------------------;
 0000012C			PropSpacing PROC
 0000012C  83 F8 0A			cmp				eax, 10
 0000012F  7C 0E			jl				singleDigit
 00000131  83 F8 64			cmp				eax, 100
 00000134  7C 10			jl				doubleDigit
 00000136  3D 000003E8			cmp				eax, 1000
 0000013B  7C 10			jl				tripleDigit
 0000013D  EB 15			jmp				quadrupleDigit

 0000013F				singleDigit:
 0000013F  BF 00000005				mov			edi, 5
 00000144  EB 15				jmp			printLoop
 00000146				doubleDigit:
 00000146  BF 00000004				mov			edi, 4
 0000014B  EB 0E				jmp			printLoop
 0000014D				tripleDigit:
 0000014D  BF 00000003				mov			edi, 3
 00000152  EB 07				jmp			printLoop
 00000154				quadrupleDigit:
 00000154  BF 00000002				mov			edi, 2
 00000159  EB 00				jmp			printLoop

 0000015B				printLoop:
						mWrite		" "
 0000576D		     1		.data
 0000576D 20 00		     1		??0008	BYTE	" ", 0
 0000015B		     1		.code
 0000015B  52		     1		push	edx
 0000015C  BA 0000576D R     1		mov		edx, OFFSET ??0008
 00000161  E8 00000000 E     1		call	WriteString
 00000166  5A		     1		pop		edx
 00000167  4F					dec			edi
 00000168  83 FF 00				cmp			edi, 0
 0000016B  7F EE				jg			printLoop
 0000016D  C3					ret
 0000016E			PropSpacing	ENDP

				;---------------------------------------------------------------;
				;	The VerifyDuplicates procedure will be called each time a	;
				;	a value is about to be inserted into the unsorted list.		;
				;	This will ensure that the list remains filled with variable	;
				;	values.														;
				;																;
				;	Parameters:		push all registers to stack to save any		;
				;						valuable information. Then the compare	;
				;						value (putting it at ebp + 8)			;
				;	Returns:		edi = 1 if duplicate, 0 if not duplicate	;
				;	Pre-Conditions:	ebp + 8 contains an integer					;
				;	Changed Regs:	eax, ecx, ebx, esi, edi, ebp				;
				;---------------------------------------------------------------;
 0000016E			VerifyDuplicates PROC
 0000016E  55				push			ebp
 0000016F  8B EC			mov				ebp, esp

 00000171  BB 00000000			mov				ebx, 0
 00000176  BE 00000000 R		mov				esi, OFFSET unsorted_list
 0000017B				LoopThroughArray:
 0000017B  8B 04 9E				mov			eax, [esi + ebx * 4]																	; move current index value to eax
 0000017E  8B 4D 08				mov			ecx, [ebp + 8]																			; move reference generated value to ecx
 00000181  83 F8 00				cmp			eax, 0																					; first 0 we encounter is the end of the array
 00000184  74 16				je			NoDuplicateValue																		; if we're still in the loop and hit a 0, there were no dupes
 00000186  3B C1				cmp			eax, ecx																				; compare generated to current array index
 00000188  74 0B				je			DuplicateValue																			; if they're the same it's equal
 0000018A  43					inc			ebx																						; next index
 0000018B  81 FB 000001F4			cmp			ebx, LENGTHOF unsorted_list																; test if we're at the end of the list
 00000191  74 09				je			NoDuplicateValue
 00000193  75 E6				jne			LoopThroughArray
 00000195				DuplicateValue:
 00000195  BF 00000001				mov			edi, 1																					; return 1 (for compare method to know it's a dupe)
						;mWriteDec	ecx
						;mWriteLn	" is a duplicate value!"
 0000019A  5D					pop			ebp
 0000019B  C3					ret
 0000019C				NoDuplicateValue:
 0000019C  BF 00000000				mov			edi, 0																					; return 0 (for compare method to know it's not a dupe)
						;mWriteDec	ecx
						;mWriteLn	" is not a duplicate value!"
 000001A1  5D					pop			ebp
 000001A2  C3					ret
 000001A3			VerifyDuplicates ENDP

				;#region File Data Input

				;---------------------------------------------------------------;
				;	The LoadFileOption procedure is called when the user chose	;
				;	to load the RBT with values off a file, specifically from	;
				;	input.txt. If the file doesn't exist, we will warn the user	;
				;	then quit.													;
				;																;
				;	Parameters:		n/a											;
				;	Returns:		n/a											;
				;	Pre-Conditions:	file.txt exists								;
				;	Changed Regs:	
				;---------------------------------------------------------------;
 000001A3			LoadFileOption PROC
					mWriteLn		"Loading data from input.txt..."
 0000576F		     2		.data
 0000576F 4C 6F 61 64 69     2		??0009	BYTE	"Loading data from input.txt...", 0
	   6E 67 20 64 61
	   74 61 20 66 72
	   6F 6D 20 69 6E
	   70 75 74 2E 74
	   78 74 2E 2E 2E
	   00
 000001A3		     2		.code
 000001A3  52		     2		push	edx
 000001A4  BA 0000576F R     2		mov		edx, OFFSET ??0009
 000001A9  E8 00000000 E     2		call	WriteString
 000001AE  5A		     2		pop		edx
 000001AF  E8 00000000 E     1		call	CrLf
					;------Open File------;
 000001B4  BA 000055F8 R		mov				edx, OFFSET inFilename
 000001B9  E8 00000000 E		call			OpenInputFile
 000001BE  A3 000055F4 R		mov				infileH, eax
					;------Read File------;
 000001C3  BA 000007D0 R		mov				edx, OFFSET buffer
 000001C8  B9 00001388			mov				ecx, BUFFER_SIZE
 000001CD  E8 00000000 E		call			ReadFromFile
 000001D2  A3 000055F0 R		mov				bytesRead, eax
					;------Close File------;
 000001D7  A1 000055F4 R		mov				eax, infileH
 000001DC  E8 00000000 E		call			CloseFile
					;------Convert Chars to Int------;
 000001E1  8D 35 000007D0 R		lea				esi, OFFSET buffer
 000001E7  8D 3D 00000000 R		lea				edi, OFFSET unsorted_list
 000001ED  BA 00000000			mov				edx, 0
 000001F2				ConvertLoop:
 000001F2  E8 00000048				call		AsciiToInt
 000001F7  89 07				mov			[edi], eax
 000001F9  47					inc			edi
 000001FA  46					inc			esi
 000001FB  42					inc			edx
 000001FC  81 FA 000001F3			cmp			edx, MAXIMUM - 1																		; We hit the max number of inputs allowed, don't convert the rest of the file
 00000202  75 EE				jne			ConvertLoop
 00000204  EB 00				jmp			FinishUp

 00000206				FinishUp:
 00000206  8B C2				mov			eax, edx
 00000208  40					inc			eax
						mWrite		"Now Printing "
 0000578E		     1		.data
 0000578E 4E 6F 77 20 50     1		??000A	BYTE	"Now Printing ", 0
	   72 69 6E 74 69
	   6E 67 20 00
 00000209		     1		.code
 00000209  52		     1		push	edx
 0000020A  BA 0000578E R     1		mov		edx, OFFSET ??000A
 0000020F  E8 00000000 E     1		call	WriteString
 00000214  5A		     1		pop		edx
						mWriteDec	eax
 00000215  50		     1		push	eax
 00000216  8B C0	     1		mov		eax, eax
 00000218  E8 00000000 E     1		call	WriteDec
 0000021D  58		     1		pop		eax
						mWriteLn	" values from input.txt to insert into tree:"
 0000579C		     2		.data
 0000579C 20 76 61 6C 75     2		??000B	BYTE	" values from input.txt to insert into tree:", 0
	   65 73 20 66 72
	   6F 6D 20 69 6E
	   70 75 74 2E 74
	   78 74 20 74 6F
	   20 69 6E 73 65
	   72 74 20 69 6E
	   74 6F 20 74 72
	   65 65 3A 00
 0000021E		     2		.code
 0000021E  52		     2		push	edx
 0000021F  BA 0000579C R     2		mov		edx, OFFSET ??000B
 00000224  E8 00000000 E     2		call	WriteString
 00000229  5A		     2		pop		edx
 0000022A  E8 00000000 E     1		call	CrLf
 0000022F  E8 FFFFFE9C				call		PrintUnsortedList																		; give the user a full list of unsorted values
 00000234  68 00000000 R			push		OFFSET unsorted_list																	; make sure we have access to the unsorted list
 00000239  E8 000001A9				call		SortToTree																				; call the sort procedure
 0000023E  C3					ret
 0000023F			LoadFileOption ENDP

 0000023F			AsciiToInt PROC
 0000023F  B9 00000000			mov				ecx, 0
 00000244  B8 00000000			mov				eax, 0
 00000249				nextDigit:
 00000249  8A 1E				mov			bl, [esi]
 0000024B  80 FB 30				cmp			bl, '0'
 0000024E  7C 11				jl			LoopFinished
 00000250  80 FB 39				cmp			bl, '9'
 00000253  7F 0C				jg			LoopFinished
 00000255  80 C3 D0				add			bl, -30h
 00000258  6B C0 0A				imul		eax, 10
 0000025B  03 C3				add			eax, ebx
						;mov		[esi], eax
						;mov		[edi], eax
 0000025D  41					inc			ecx
 0000025E  46					inc			esi
						;inc		edi
 0000025F  EB E8				jmp			nextDigit
 00000261				LoopFinished:
 00000261  C3					ret
 00000262			AsciiToInt ENDP

				;#endregion

				;#region Generate Data Input

				;---------------------------------------------------------------;
				;	The GenerateValuesOption procedure is called when the user	;
				;	chose to load the RBT with auto-generated values by the		;
				;	program. The user specifies how many values to generate.	;
				;																;
				;	Parameters:		n/a											;
				;	Returns:		n/a											;
				;	Pre-Conditions:	n/a											;
				;	Changed Regs:	eax, edx, ecx, ebx, esi						;
				;---------------------------------------------------------------;
 00000262			GenerateValuesOption PROC
 00000262  E8 00000000 E		call			Randomize																				; set the time seed for the randomize functions in order to keep the generator psuedo-random
 00000267  E8 00000064			call			GetGenerationCount

					mWrite			"Now generating "
 000057C8		     1		.data
 000057C8 4E 6F 77 20 67     1		??000C	BYTE	"Now generating ", 0
	   65 6E 65 72 61
	   74 69 6E 67 20
	   00
 0000026C		     1		.code
 0000026C  52		     1		push	edx
 0000026D  BA 000057C8 R     1		mov		edx, OFFSET ??000C
 00000272  E8 00000000 E     1		call	WriteString
 00000277  5A		     1		pop		edx
					mWriteDec		eax
 00000278  50		     1		push	eax
 00000279  8B C0	     1		mov		eax, eax
 0000027B  E8 00000000 E     1		call	WriteDec
 00000280  58		     1		pop		eax
					mWriteLn			" values to insert into tree:"
 000057D8		     2		.data
 000057D8 20 76 61 6C 75     2		??000D	BYTE	" values to insert into tree:", 0
	   65 73 20 74 6F
	   20 69 6E 73 65
	   72 74 20 69 6E
	   74 6F 20 74 72
	   65 65 3A 00
 00000281		     2		.code
 00000281  52		     2		push	edx
 00000282  BA 000057D8 R     2		mov		edx, OFFSET ??000D
 00000287  E8 00000000 E     2		call	WriteString
 0000028C  5A		     2		pop		edx
 0000028D  E8 00000000 E     1		call	CrLf

 00000292  8B C8			mov				ecx, eax																				; loop through the desired generationcount num held on eax.
 00000294  BE 00000000 R		mov				esi, OFFSET unsorted_list																; point to array address
 00000299  BB 00000000			mov				ebx, 0
 0000029E				GenerateRandNum:
 0000029E  B8 000003E8				mov			eax, MAXIMUMVAL																			; eax will be the max range to generate
 000002A3  48					dec			eax																						; 999 is where we want, because randomrange includes 0.
 000002A4  E8 00000000 E			call		RandomRange
 000002A9  40					inc			eax																						; this now gives us a random value from 1 to 1000.
						
 000002AA  53					push		ebx																						; save all register values
 000002AB  51					push		ecx
 000002AC  50					push		eax
 000002AD  E8 FFFFFEBC				call		VerifyDuplicates																		; Ensure there is no dupe
 000002B2  58					pop			eax
 000002B3  59					pop			ecx
 000002B4  5B					pop			ebx																						; restore all register values
						
 000002B5  83 FF 01				cmp			edi, 1																					; VerifyDuplicates will return 1 if true
 000002B8  74 E4				je			GenerateRandNum																			; if true, we need to gen a different number on the same index
 000002BA  89 04 9E				mov			[esi + ebx * 4], eax																	; no dupe, store the generated value into array[loop count * 4 bytes]
 000002BD  43					inc			ebx																						; update index counter
 000002BE  E2 DE				loop		GenerateRandNum																			; keep going until ecx = 0

 000002C0  E8 FFFFFE0B			call			PrintUnsortedList																		; give the user a full list of unsorted values
 000002C5  68 00000000 R		push			OFFSET unsorted_list																	; make sure we have access to the unsorted list
 000002CA  E8 00000118			call			SortToTree																				; call the sort procedure
 000002CF  C3				ret
 000002D0			GenerateValuesOption ENDP

				;---------------------------------------------------------------;
				;	The GetGenerationCount procedure gets from user input their	;
				;	desired number of values to be added to the tree within the	;
				;	defined range of 1-500.										;
				;																;
				;	Parameters:		n/a											;
				;	Returns:		Generation count to eax						;
				;	Pre-Conditions:	n/a											;
				;	Changed Regs:	eax, edx									;
				;---------------------------------------------------------------;
 000002D0			GetGenerationCount PROC
 000002D0				getInput:
						mWrite		"Please enter how many values you wish to generate [1-500]: "
 000057F5		     1		.data
 000057F5 50 6C 65 61 73     1		??000E	BYTE	"Please enter how many values you wish to generate [1-500]: ", 0
	   65 20 65 6E 74
	   65 72 20 68 6F
	   77 20 6D 61 6E
	   79 20 76 61 6C
	   75 65 73 20 79
	   6F 75 20 77 69
	   73 68 20 74 6F
	   20 67 65 6E 65
	   72 61 74 65 20
	   5B 31 2D 35 30
	   30 5D 3A 20 00
 000002D0		     1		.code
 000002D0  52		     1		push	edx
 000002D1  BA 000057F5 R     1		mov		edx, OFFSET ??000E
 000002D6  E8 00000000 E     1		call	WriteString
 000002DB  5A		     1		pop		edx
 000002DC  E8 00000000 E			call		ReadDec

 000002E1				VerifyInput:
 000002E1  83 F8 01				cmp			eax, MINIMUM																			; user inputed a value too low
 000002E4  7C 09				jl			InvalidInput
 000002E6  3D 000001F4				cmp			eax, MAXIMUM																			; user inputed a value too high
 000002EB  7F 02				jg			InvalidInput
 000002ED  EB 28				jmp			ValidInput																				; input is within range

 000002EF				InvalidInput:
						mWrite		"The entered value "
 00005831		     1		.data
 00005831 54 68 65 20 65     1		??000F	BYTE	"The entered value ", 0
	   6E 74 65 72 65
	   64 20 76 61 6C
	   75 65 20 00
 000002EF		     1		.code
 000002EF  52		     1		push	edx
 000002F0  BA 00005831 R     1		mov		edx, OFFSET ??000F
 000002F5  E8 00000000 E     1		call	WriteString
 000002FA  5A		     1		pop		edx
						mWriteDec	eax
 000002FB  50		     1		push	eax
 000002FC  8B C0	     1		mov		eax, eax
 000002FE  E8 00000000 E     1		call	WriteDec
 00000303  58		     1		pop		eax
						mWriteLn	" is outside of the designated range."
 00005844		     2		.data
 00005844 20 69 73 20 6F     2		??0010	BYTE	" is outside of the designated range.", 0
	   75 74 73 69 64
	   65 20 6F 66 20
	   74 68 65 20 64
	   65 73 69 67 6E
	   61 74 65 64 20
	   72 61 6E 67 65
	   2E 00
 00000304		     2		.code
 00000304  52		     2		push	edx
 00000305  BA 00005844 R     2		mov		edx, OFFSET ??0010
 0000030A  E8 00000000 E     2		call	WriteString
 0000030F  5A		     2		pop		edx
 00000310  E8 00000000 E     1		call	CrLf
 00000315  EB B9				jmp			getInput

 00000317				ValidInput:
 00000317  C3					ret																									; return generation count on eax
 00000318			GetGenerationCount ENDP

				;#endregion

				;#region User Input Data

				;---------------------------------------------------------------;
				;	The InputValuesOption procedure is called when the user		;
				;	chose to load the RBT with user specified values. The user	;
				;	can continue adding, deleting and searching until further	;
				;	specified.													;
				;																;
				;	Parameters:		n/a											;
				;	Returns:		n/a											;
				;	Pre-Conditions:	n/a											;
				;	Changed Regs:	eax, ecx, edx, esi							;
				;---------------------------------------------------------------;
 00000318			InputValuesOption PROC
 00000318  BE 00000000 R		mov				esi, OFFSET unsorted_list
 0000031D  B9 00000000			mov				ecx, 0
 00000322				NewInput:
 00000322  E8 00000086				call		GetUserInputData
 00000327  83 F8 00				cmp			eax, 0
 0000032A  74 4B				je			DoneWithInput
 0000032C  EB 00				jmp			AddToArray
 0000032E				AddToArray:
 0000032E  51					push		ecx																						; save all register values
 0000032F  50					push		eax
 00000330  E8 FFFFFE39				call		VerifyDuplicates																		; Ensure there is no dupe
 00000335  58					pop			eax
 00000336  59					pop			ecx																						; restore all register values
						
 00000337  83 FF 01				cmp			edi, 1																					; VerifyDuplicates will return 1 if true
 0000033A  74 0E				je			DuplicateInput
 0000033C  89 04 8E				mov			[esi + ecx * 4], eax																	; store value to array[index * 4 bytes]
 0000033F  41					inc			ecx																						; next index value
 00000340  81 F9 000001F4			cmp			ecx, MAXIMUM																			; make sure we haven't hit 500
 00000346  74 1E				je			MaxInputs
 00000348  EB D8				jmp			NewInput
 0000034A				DuplicateInput:
						mWriteDec	eax
 0000034A  50		     1		push	eax
 0000034B  8B C0	     1		mov		eax, eax
 0000034D  E8 00000000 E     1		call	WriteDec
 00000352  58		     1		pop		eax
						mWriteLn	" was a duplicate! Please enter a different value."
 00005869		     2		.data
 00005869 20 77 61 73 20     2		??0011	BYTE	" was a duplicate! Please enter a different value.", 0
	   61 20 64 75 70
	   6C 69 63 61 74
	   65 21 20 50 6C
	   65 61 73 65 20
	   65 6E 74 65 72
	   20 61 20 64 69
	   66 66 65 72 65
	   6E 74 20 76 61
	   6C 75 65 2E 00
 00000353		     2		.code
 00000353  52		     2		push	edx
 00000354  BA 00005869 R     2		mov		edx, OFFSET ??0011
 00000359  E8 00000000 E     2		call	WriteString
 0000035E  5A		     2		pop		edx
 0000035F  E8 00000000 E     1		call	CrLf
 00000364  EB BC				jmp			NewInput
 00000366				MaxInputs:
						mWriteLn	"You've Inputted the max number of inputs for the tree.."
 0000589B		     2		.data
 0000589B 59 6F 75 27 76     2		??0012	BYTE	"You've Inputted the max number of inputs for the tree..", 0
	   65 20 49 6E 70
	   75 74 74 65 64
	   20 74 68 65 20
	   6D 61 78 20 6E
	   75 6D 62 65 72
	   20 6F 66 20 69
	   6E 70 75 74 73
	   20 66 6F 72 20
	   74 68 65 20 74
	   72 65 65 2E 2E
	   00
 00000366		     2		.code
 00000366  52		     2		push	edx
 00000367  BA 0000589B R     2		mov		edx, OFFSET ??0012
 0000036C  E8 00000000 E     2		call	WriteString
 00000371  5A		     2		pop		edx
 00000372  E8 00000000 E     1		call	CrLf
 00000377				DoneWithInput:
						mWrite		"Now printing your "
 000058D3		     1		.data
 000058D3 4E 6F 77 20 70     1		??0013	BYTE	"Now printing your ", 0
	   72 69 6E 74 69
	   6E 67 20 79 6F
	   75 72 20 00
 00000377		     1		.code
 00000377  52		     1		push	edx
 00000378  BA 000058D3 R     1		mov		edx, OFFSET ??0013
 0000037D  E8 00000000 E     1		call	WriteString
 00000382  5A		     1		pop		edx
						mWriteDec	ecx
 00000383  50		     1		push	eax
 00000384  8B C1	     1		mov		eax, ecx
 00000386  E8 00000000 E     1		call	WriteDec
 0000038B  58		     1		pop		eax
						mWriteLn	" inputted values:"
 000058E6		     2		.data
 000058E6 20 69 6E 70 75     2		??0014	BYTE	" inputted values:", 0
	   74 74 65 64 20
	   76 61 6C 75 65
	   73 3A 00
 0000038C		     2		.code
 0000038C  52		     2		push	edx
 0000038D  BA 000058E6 R     2		mov		edx, OFFSET ??0014
 00000392  E8 00000000 E     2		call	WriteString
 00000397  5A		     2		pop		edx
 00000398  E8 00000000 E     1		call	CrLf
 0000039D  E8 FFFFFD2E				call		PrintUnsortedList																		; give the user a full list of unsorted values
 000003A2  68 00000000 R			push		OFFSET unsorted_list																	; make sure we have access to the unsorted list
 000003A7  E8 0000003B				call		SortToTree																				; call the sort procedure
 000003AC  C3					ret
 000003AD			InputValuesOption ENDP

				;---------------------------------------------------------------;
				;	The GetUserInputData procedure is called when the program	;
				;	needs to fill the array with data. It will continue to be	;
				;	called while the user wishes to add more values to the tree.;
				;																;
				;	Parameters:		n/a											;
				;	Returns:		eax contains the new inputted value			;
				;	Pre-Conditions:	n/a											;
				;	Changed Regs:	eax, edx									;
				;---------------------------------------------------------------;
 000003AD			GetUserInputData PROC
 000003AD				GetValue:
 000003AD  33 C0				xor			eax, eax																				; completly clear eax register
						mWrite		"Please enter a data value [1-1000] or 0 to stop:"
 000058F8		     1		.data
 000058F8 50 6C 65 61 73     1		??0015	BYTE	"Please enter a data value [1-1000] or 0 to stop:", 0
	   65 20 65 6E 74
	   65 72 20 61 20
	   64 61 74 61 20
	   76 61 6C 75 65
	   20 5B 31 2D 31
	   30 30 30 5D 20
	   6F 72 20 30 20
	   74 6F 20 73 74
	   6F 70 3A 00
 000003AF		     1		.code
 000003AF  52		     1		push	edx
 000003B0  BA 000058F8 R     1		mov		edx, OFFSET ??0015
 000003B5  E8 00000000 E     1		call	WriteString
 000003BA  5A		     1		pop		edx
 000003BB  E8 00000000 E			call		ReadDec

 000003C0				VerifyInput:
 000003C0  3D 000003E8				cmp			eax, MAXIMUMVAL
 000003C5  7F 0C				jg			InvalidInput
 000003C7  83 F8 00				cmp			eax, 0
 000003CA  74 1A				je			ValidInput
 000003CC  83 F8 01				cmp			eax, MINIMUM
 000003CF  7C 02				jl			InvalidInput
 000003D1  EB 13				jmp			ValidInput

 000003D3				InvalidInput:
						mWriteLn	"The entered value was not within the defined range."
 00005929		     2		.data
 00005929 54 68 65 20 65     2		??0016	BYTE	"The entered value was not within the defined range.", 0
	   6E 74 65 72 65
	   64 20 76 61 6C
	   75 65 20 77 61
	   73 20 6E 6F 74
	   20 77 69 74 68
	   69 6E 20 74 68
	   65 20 64 65 66
	   69 6E 65 64 20
	   72 61 6E 67 65
	   2E 00
 000003D3		     2		.code
 000003D3  52		     2		push	edx
 000003D4  BA 00005929 R     2		mov		edx, OFFSET ??0016
 000003D9  E8 00000000 E     2		call	WriteString
 000003DE  5A		     2		pop		edx
 000003DF  E8 00000000 E     1		call	CrLf
 000003E4  EB C7				jmp			GetValue
 000003E6				ValidInput:
 000003E6  C3					ret
 000003E7			GetUserInputData ENDP


				;#endregion

				;#region Red-Black Tree Methods

 000003E7			SortToTree PROC
 000003E7  55				push			ebp
 000003E8  8B EC			mov				ebp, esp

					mWriteLn		"Now sorting list to Red-Black Tree:"
 0000595D		     2		.data
 0000595D 4E 6F 77 20 73     2		??0017	BYTE	"Now sorting list to Red-Black Tree:", 0
	   6F 72 74 69 6E
	   67 20 6C 69 73
	   74 20 74 6F 20
	   52 65 64 2D 42
	   6C 61 63 6B 20
	   54 72 65 65 3A
	   00
 000003EA		     2		.code
 000003EA  52		     2		push	edx
 000003EB  BA 0000595D R     2		mov		edx, OFFSET ??0017
 000003F0  E8 00000000 E     2		call	WriteString
 000003F5  5A		     2		pop		edx
 000003F6  E8 00000000 E     1		call	CrLf
					mWriteLn		"lol if you thought this would be done first you're incredibly mistaken"
 00005981		     2		.data
 00005981 6C 6F 6C 20 69     2		??0018	BYTE	"lol if you thought this would be done first you're incredibly mistaken", 0
	   66 20 79 6F 75
	   20 74 68 6F 75
	   67 68 74 20 74
	   68 69 73 20 77
	   6F 75 6C 64 20
	   62 65 20 64 6F
	   6E 65 20 66 69
	   72 73 74 20 79
	   6F 75 27 72 65
	   20 69 6E 63 72
	   65 64 69 62 6C
	   79 20 6D 69 73
	   74 61 6B 65 6E
	   00
 000003FB		     2		.code
 000003FB  52		     2		push	edx
 000003FC  BA 00005981 R     2		mov		edx, OFFSET ??0018
 00000401  E8 00000000 E     2		call	WriteString
 00000406  5A		     2		pop		edx
 00000407  E8 00000000 E     1		call	CrLf

 0000040C  5D				pop				ebp
 0000040D  C2 0004			ret 4
 00000410			SortToTree ENDP


				;#endregion

				END main																									; the symbolyses that the main program is finished
Microsoft (R) Macro Assembler Version 14.16.27027.1	    03/14/19 14:47:20
,Project 7 - RedBlackTree		(RedBlackTree.asm    Symbols 2 - 1




Macros:

                N a m e                 Type

mWriteDec  . . . . . . . . . . .	Proc
mWriteLn . . . . . . . . . . . .	Proc
mWriteStringLn . . . . . . . . .	Proc
mWriteString . . . . . . . . . .	Proc
mWrite . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 000059C8 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000410 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

AsciiToInt . . . . . . . . . . .	P Near	 0000023F _TEXT	Length= 00000023 Public STDCALL
  nextDigit  . . . . . . . . . .	L Near	 00000249 _TEXT	
  LoopFinished . . . . . . . . .	L Near	 00000261 _TEXT	
CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExecuteRunOption . . . . . . . .	P Near	 0000009B _TEXT	Length= 00000035 Public STDCALL
  fileOption . . . . . . . . . .	L Near	 000000AC _TEXT	
  generateOption . . . . . . . .	L Near	 000000B2 _TEXT	
  inputOption  . . . . . . . . .	L Near	 000000B8 _TEXT	
  invalidOption  . . . . . . . .	L Near	 000000BE _TEXT	
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GenerateValuesOption . . . . . .	P Near	 00000262 _TEXT	Length= 0000006E Public STDCALL
  GenerateRandNum  . . . . . . .	L Near	 0000029E _TEXT	
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetGenerationCount . . . . . . .	P Near	 000002D0 _TEXT	Length= 00000048 Public STDCALL
  getInput . . . . . . . . . . .	L Near	 000002D0 _TEXT	
  VerifyInput  . . . . . . . . .	L Near	 000002E1 _TEXT	
  InvalidInput . . . . . . . . .	L Near	 000002EF _TEXT	
  ValidInput . . . . . . . . . .	L Near	 00000317 _TEXT	
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUserInputData . . . . . . . .	P Near	 000003AD _TEXT	Length= 0000003A Public STDCALL
  GetValue . . . . . . . . . . .	L Near	 000003AD _TEXT	
  VerifyInput  . . . . . . . . .	L Near	 000003C0 _TEXT	
  InvalidInput . . . . . . . . .	L Near	 000003D3 _TEXT	
  ValidInput . . . . . . . . . .	L Near	 000003E6 _TEXT	
GetUserRunOption . . . . . . . .	P Near	 0000006A _TEXT	Length= 00000031 Public STDCALL
  startUserInput . . . . . . . .	L Near	 0000006A _TEXT	
  verifyUserInput  . . . . . . .	L Near	 0000007D _TEXT	
  invalidInput . . . . . . . . .	L Near	 00000088 _TEXT	
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InputValuesOption  . . . . . . .	P Near	 00000318 _TEXT	Length= 00000095 Public STDCALL
  NewInput . . . . . . . . . . .	L Near	 00000322 _TEXT	
  AddToArray . . . . . . . . . .	L Near	 0000032E _TEXT	
  DuplicateInput . . . . . . . .	L Near	 0000034A _TEXT	
  MaxInputs  . . . . . . . . . .	L Near	 00000366 _TEXT	
  DoneWithInput  . . . . . . . .	L Near	 00000377 _TEXT	
Intro  . . . . . . . . . . . . .	P Near	 00000016 _TEXT	Length= 00000054 Public STDCALL
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadFileOption . . . . . . . . .	P Near	 000001A3 _TEXT	Length= 0000009C Public STDCALL
  ConvertLoop  . . . . . . . . .	L Near	 000001F2 _TEXT	
  FinishUp . . . . . . . . . . .	L Near	 00000206 _TEXT	
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PrintUnsortedList  . . . . . . .	P Near	 000000D0 _TEXT	Length= 0000005C Public STDCALL
  PrintLoop  . . . . . . . . . .	L Near	 000000E2 _TEXT	
  NewLine  . . . . . . . . . . .	L Near	 000000FB _TEXT	
  OldLine  . . . . . . . . . . .	L Near	 00000107 _TEXT	
  NextCall . . . . . . . . . . .	L Near	 0000011A _TEXT	
  EndPrint . . . . . . . . . . .	L Near	 00000125 _TEXT	
PropSpacing  . . . . . . . . . .	P Near	 0000012C _TEXT	Length= 00000042 Public STDCALL
  singleDigit  . . . . . . . . .	L Near	 0000013F _TEXT	
  doubleDigit  . . . . . . . . .	L Near	 00000146 _TEXT	
  tripleDigit  . . . . . . . . .	L Near	 0000014D _TEXT	
  quadrupleDigit . . . . . . . .	L Near	 00000154 _TEXT	
  printLoop  . . . . . . . . . .	L Near	 0000015B _TEXT	
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SortToTree . . . . . . . . . . .	P Near	 000003E7 _TEXT	Length= 00000029 Public STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerifyDuplicates . . . . . . . .	P Near	 0000016E _TEXT	Length= 00000035 Public STDCALL
  LoopThroughArray . . . . . . .	L Near	 0000017B _TEXT	
  DuplicateValue . . . . . . . .	L Near	 00000195 _TEXT	
  NoDuplicateValue . . . . . . .	L Near	 0000019C _TEXT	
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000016 Public STDCALL
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

??0000 . . . . . . . . . . . . .	Byte	 00005602 _DATA	
??0001 . . . . . . . . . . . . .	Byte	 00005649 _DATA	
??0002 . . . . . . . . . . . . .	Byte	 00005668 _DATA	
??0003 . . . . . . . . . . . . .	Byte	 00005693 _DATA	
??0004 . . . . . . . . . . . . .	Byte	 000056B4 _DATA	
??0005 . . . . . . . . . . . . .	Byte	 000056D5 _DATA	
??0006 . . . . . . . . . . . . .	Byte	 0000570E _DATA	
??0007 . . . . . . . . . . . . .	Byte	 0000576B _DATA	
??0008 . . . . . . . . . . . . .	Byte	 0000576D _DATA	
??0009 . . . . . . . . . . . . .	Byte	 0000576F _DATA	
??000A . . . . . . . . . . . . .	Byte	 0000578E _DATA	
??000B . . . . . . . . . . . . .	Byte	 0000579C _DATA	
??000C . . . . . . . . . . . . .	Byte	 000057C8 _DATA	
??000D . . . . . . . . . . . . .	Byte	 000057D8 _DATA	
??000E . . . . . . . . . . . . .	Byte	 000057F5 _DATA	
??000F . . . . . . . . . . . . .	Byte	 00005831 _DATA	
??0010 . . . . . . . . . . . . .	Byte	 00005844 _DATA	
??0011 . . . . . . . . . . . . .	Byte	 00005869 _DATA	
??0012 . . . . . . . . . . . . .	Byte	 0000589B _DATA	
??0013 . . . . . . . . . . . . .	Byte	 000058D3 _DATA	
??0014 . . . . . . . . . . . . .	Byte	 000058E6 _DATA	
??0015 . . . . . . . . . . . . .	Byte	 000058F8 _DATA	
??0016 . . . . . . . . . . . . .	Byte	 00005929 _DATA	
??0017 . . . . . . . . . . . . .	Byte	 0000595D _DATA	
??0018 . . . . . . . . . . . . .	Byte	 00005981 _DATA	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
BUFFER_SIZE  . . . . . . . . . .	Number	 00001388h   
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
MAXIMUMVAL . . . . . . . . . . .	Number	 000003E8h   
MAXIMUM  . . . . . . . . . . . .	Number	 000001F4h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MINIMUM  . . . . . . . . . . . .	Number	 00000001h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
buffer . . . . . . . . . . . . .	DWord	 000007D0 _DATA	
bytesRead  . . . . . . . . . . .	DWord	 000055F0 _DATA	
cyan . . . . . . . . . . . . . .	Number	 00000003h   
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
inFilename . . . . . . . . . . .	Byte	 000055F8 _DATA	
infileH  . . . . . . . . . . . .	DWord	 000055F4 _DATA	
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
magenta  . . . . . . . . . . . .	Number	 00000005h   
red  . . . . . . . . . . . . . .	Number	 00000004h   
unsorted_list  . . . . . . . . .	DWord	 00000000 _DATA	
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
